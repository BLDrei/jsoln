package com.bldrei.jsoln;import com.bldrei.jsoln.cache.Cache;import com.bldrei.jsoln.cache.RecordDeserializationInfo;import com.bldrei.jsoln.exception.JsolnException;import com.bldrei.jsoln.util.ClassTreeWithConverters;import com.bldrei.jsoln.util.DeserializeUtil;import com.bldrei.jsoln.util.SerializeUtil;import com.bldrei.jsoln.util.TypeUtil;import com.fasterxml.jackson.core.JsonGenerator;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.node.ArrayNode;import com.fasterxml.jackson.databind.node.JsonNodeFactory;import com.fasterxml.jackson.databind.node.ObjectNode;import com.sun.source.tree.ClassTree;import jdk.dynalink.linker.support.TypeUtilities;import lombok.NonNull;import lombok.SneakyThrows;import org.jetbrains.annotations.NotNull;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;public final class Jsoln {  private Jsoln() {}  private static final ObjectMapper objectMapper = new ObjectMapper()    .enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)    .enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)    .setNodeFactory(JsonNodeFactory.withExactBigDecimals(true))    .configure(DeserializationFeature.FAIL_ON_TRAILING_TOKENS, true)    .enable(JsonGenerator.Feature.STRICT_DUPLICATE_DETECTION);  public static <T> String serialize(@NonNull @NotNull T obj) {    if (!obj.getClass().isRecord()) throw new IllegalStateException("Map not implemented yet");    var recordDeserInfo = Cache.getRecordDeserializationInfo(obj.getClass()).getClassTree(); //todo: deser info for ser????    return SerializeUtil.stringify(obj, recordDeserInfo, null);  }  @SneakyThrows  @SuppressWarnings("unchecked")  public static <T> T deserialize(@NonNull @NotNull String fullJson, @NonNull @NotNull Class<T> tClass) {    var readerOutput = objectMapper.readTree(fullJson);    return (T) deserializeJsonTree(readerOutput, tClass);  }  @SneakyThrows  @SuppressWarnings("unchecked")  public static <T> T deserialize(@NonNull @NotNull String fullJson, @NonNull @NotNull TypeReference<T> typeReference) {    var readerOutput = objectMapper.readTree(fullJson);    return (T) deserializeJsonTree(readerOutput, typeReference.getType());  }  private static Object deserializeJsonTree(@NonNull @NotNull JsonNode jsonNode, @NonNull @NotNull Type type) {    return switch (jsonNode) {      case ArrayNode arrayNode        when TypeUtil.canBeDeserializedFromArrayNode(type) -> deserializeToList(arrayNode, type);      case ObjectNode objectNode -> deserializeRecordObject(objectNode, type);      default -> throw new IllegalArgumentException();    };  }  @SuppressWarnings("unchecked")  private static Object deserializeRecordObject(@NotNull JsonNode jsonNode, @NotNull Type type) {    Class<?> clazz = switch (type) {      case Class cl -> cl;      default -> throw new IllegalArgumentException();    };    if (!clazz.isRecord()) throw new IllegalArgumentException();    RecordDeserializationInfo recordDeserializationInfo = Cache.getRecordDeserializationInfo(clazz);    return DeserializeUtil.javaifyJsonModel(jsonNode, recordDeserializationInfo.getClassTree());  }  @SuppressWarnings("unchecked")  private static Object deserializeToList(@NotNull JsonNode jsonNode, @NotNull Type type) {    return DeserializeUtil.javaifyJsonModel(jsonNode, ClassTreeWithConverters.fromType(type));  }}