package com.bldrei.jsoln;import com.bldrei.jsoln.cache.RecordDeserializationInfo;import com.bldrei.jsoln.util.ClassTreeWithConverters;import com.bldrei.jsoln.util.DeserializeUtil;import com.bldrei.jsoln.util.SerializeUtil;import com.bldrei.jsoln.util.TypeUtil;import com.fasterxml.jackson.core.JsonGenerator;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.node.ArrayNode;import com.fasterxml.jackson.databind.node.JsonNodeFactory;import com.fasterxml.jackson.databind.node.ObjectNode;import lombok.NonNull;import lombok.RequiredArgsConstructor;import lombok.SneakyThrows;import org.jetbrains.annotations.NotNull;import java.lang.reflect.Type;@RequiredArgsConstructorpublic final class Jsoln {  private final Configuration conf;  public Jsoln() {    this(Configuration.defaultConf());  }  private final ObjectMapper objectMapper = new ObjectMapper()    .enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)    .enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)    .setNodeFactory(JsonNodeFactory.withExactBigDecimals(true))    .configure(DeserializationFeature.FAIL_ON_TRAILING_TOKENS, true)    .enable(JsonGenerator.Feature.STRICT_DUPLICATE_DETECTION);  public <T> String serialize(@NonNull @NotNull T obj) {    if (!obj.getClass().isRecord()) throw new IllegalStateException("Map not implemented yet");    var recordDeserInfo = conf.getCache().getRecordDeserializationInfo(obj.getClass(), conf).getClassTree();    return SerializeUtil.stringify(obj, recordDeserInfo, null, conf);  }  @SneakyThrows  @SuppressWarnings("unchecked")  public <T> T deserialize(@NonNull @NotNull String fullJson, @NonNull @NotNull Class<T> tClass) {    var readerOutput = objectMapper.readTree(fullJson);    return (T) deserializeJsonTree(readerOutput, tClass);  }  @SneakyThrows  @SuppressWarnings("unchecked")  public <T> T deserialize(@NonNull @NotNull String fullJson, @NonNull @NotNull TypeReference<T> typeReference) {    var readerOutput = objectMapper.readTree(fullJson);    return (T) deserializeJsonTree(readerOutput, typeReference.getType());  }  private Object deserializeJsonTree(@NonNull @NotNull JsonNode jsonNode, @NonNull @NotNull Type type) {    return switch (jsonNode) {      case ArrayNode arrayNode        when TypeUtil.canBeDeserializedFromArrayNode(type) -> deserializeToList(arrayNode, type);      case ObjectNode objectNode -> deserializeRecordObject(objectNode, type);      default -> throw new IllegalArgumentException();    };  }  @SuppressWarnings("unchecked")  private Object deserializeRecordObject(@NotNull JsonNode jsonNode, @NotNull Type type) {    Class<?> clazz = switch (type) {      case Class cl -> cl;      default -> throw new IllegalArgumentException();    };    if (!clazz.isRecord()) throw new IllegalArgumentException();    RecordDeserializationInfo recordDeserializationInfo = conf.getCache().getRecordDeserializationInfo(clazz, conf);    return DeserializeUtil.javaifyJsonModel(jsonNode, recordDeserializationInfo.getClassTree(), conf);  }  @SuppressWarnings("unchecked")  private Object deserializeToList(@NotNull JsonNode jsonNode, @NotNull Type type) {    return DeserializeUtil.javaifyJsonModel(jsonNode, ClassTreeWithConverters.fromType(type), conf);  }}